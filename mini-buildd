#!/usr/bin/python

import threading, Queue, signal, os, argparse, sys, daemon, logging, logging.handlers

from mini_buildd import __version__, misc, globals

log = logging.getLogger("mini_buildd")
log.addHandler(logging.StreamHandler())

class Main():
    def parse_args(self):
        parser = argparse.ArgumentParser(prog="mini-buildd",
                                         description="mini build daemon.",
                                         formatter_class=argparse.ArgumentDefaultsHelpFormatter)

        parser.add_argument('--version', action='version', version=__version__)

        parser.add_argument("-f", "--foreground", action='store_true',
                            help="Don't daemonize, log to console.")
        parser.add_argument("-W", "--httpd-bind", action='store', default="0.0.0.0:8066",
                            help="Web Server IP/Hostname and port to bind to.")
        parser.add_argument("-F", "--ftpd-bind", action='store', default="0.0.0.0:8067",
                            help="FTP Server IP/Hostname and port to bind to.")

        group_log = parser.add_argument_group("Logging")
        group_log.add_argument("-v", "--verbose", dest="verbosity", action='count', default=0,
                               help="Lower log level. Give twice for max logs.")
        group_log.add_argument("-q", "--quiet", dest="terseness", action='count', default=0,
                               help="Tighten log level. Give twice for min logs.")
        group_log.add_argument("-d", "--debug", action='store_true', default=False,
                               help="Enable 'debug mode'. This will set logging vebosity to max, and also \
tries to put external code into 'debug' mode as far as supported. Never use this for production.")
        group_log.add_argument("-l", "--loggers", action='store', default="file,syslog",
                               help="Comma-separated list of loggers (file,syslog,console) to use.")

        group_conf = parser.add_argument_group("Daemon configuration")
        group_conf.add_argument("-H", "--home", action='store', default=os.getenv('HOME'),
                                help="Run with this home dir. The only use case to change this for debugging, really.")
        group_conf.add_argument("-I", "--instdir", action='store', default="/usr/share/pyshared",
                                help="Run with this installation dir (where mini_buildd python module is located).")

        group_db = parser.add_argument_group("Database")
        group_db.add_argument("-P", "--set-admin-password", action='store', metavar="PASSWORD",
                              help="Update password for django superuser named 'admin'; user is created if non-existent yet.")
        group_db.add_argument("-C", "--create-default-config", action='store', metavar="MIRROR_URL",
                              help="Create an initial default config.")
        group_db.add_argument("-L", "--loaddata", action='store', metavar="FILE",
                              help="Import FILE to django database and exit. FILE is a absolute or relative (to 'INSTDIR/fixtures/') \
django fixture path (see 'django-admin dumpdata'), or an absolute path /PATH/*.conf for an old 0.8.x-style config.")
        group_db.add_argument("-D", "--dumpdata", action='store', metavar="APP[.MODEL]",
                              help="Dump app[.MODEL] from django database and exit (see 'django-admin loaddata').")

        p=parser.parse_args()

        # Arguments that imply foreground mode
        if p.set_admin_password or p.create_default_config or p.loaddata or p.dumpdata:
            p.foreground = True

        return p

    def _setup_globals(self):
        # Set global variables that really make no sense to
        # propagate through
        globals.DEBUG = self._args.debug

        globals.HOME_DIR = self._args.home

        globals.INCOMING_DIR = os.path.join(self._args.home, "incoming")
        globals.REPOSITORIES_DIR = os.path.join(self._args.home, "repositories")

        vardir = os.path.join(self._args.home, "var")
        globals.SPOOL_DIR    = os.path.join(vardir, "spool")
        globals.BUILDS_DIR   = os.path.join(vardir, "builds")
        globals.LOGS_DIR     = os.path.join(vardir, "logs")
        globals.CHROOTS_DIR  = os.path.join(vardir, "chroots")

        self.LOG_FILE = os.path.join(globals.LOGS_DIR, "daemon.log")

        if os.path.exists("./build/sphinx/html"):
            # A bit clumsy, but should work: Seems to be a development run
            globals.MANUAL_DIR = os.path.realpath("./build/sphinx/html")
        else:
            globals.MANUAL_DIR = os.path.realpath("/usr/share/doc/mini-buildd/html")

        # Create base directories
        misc.mkdirs(globals.INCOMING_DIR)
        misc.mkdirs(globals.REPOSITORIES_DIR)
        misc.mkdirs(globals.LOGS_DIR)

    def _setup_logging(self):
        #loggers = string.split(self._args.loggers, ",")
        loggers = self._args.loggers.split(",")
        if self._args.foreground:
            loggers.append("console")

        log_format="%(name)-22s(%(lineno)03d): %(levelname)-8s: %(message)s"

        # Clear all loggers now; this will remove the
        # preliminary console logger
        log.handlers = []

        if "file" in loggers:
            h  = logging.FileHandler(self.LOG_FILE)
            h.setFormatter(logging.Formatter("%(asctime)s " + log_format))
            log.addHandler(h)

        if "syslog" in loggers:
            h = logging.handlers.SysLogHandler(address="/dev/log", facility=logging.handlers.SysLogHandler.LOG_USER)
            h.setFormatter(logging.Formatter(log_format))
            log.addHandler(h)

        if "console" in loggers:
            h = logging.StreamHandler()
            h.setFormatter(logging.Formatter("%(asctime)s " + log_format))
            log.addHandler(h)

        # Finally, set log level
        loglevel = logging.DEBUG if self._args.debug else logging.WARNING-(10*(min(2, self._args.verbosity)-min(2, self._args.terseness)))
        log.setLevel(loglevel)

        # Global: Don't propagate exceptions that happen while logging
        logging.raiseExceptions = 0

    def __init__(self):
        self._args = self.parse_args()
        self._setup_globals()
        self._setup_logging()

    def shutdown(self, signum=-1, frame=-1):
        log.debug("Got signal: %s" % signum)
        self._run = False

    def run(self):
        from mini_buildd import webapp
        webapp = webapp.WebApp(self._args.home, instdir=self._args.instdir)

        # Extra options that exit without running as daemon
        if self._args.set_admin_password:
            webapp.set_admin_password(password=self._args.set_admin_password)
        elif self._args.create_default_config:
            webapp.create_default_config(mirror=self._args.create_default_config)
        elif self._args.loaddata:
            webapp.loaddata(f=self._args.loaddata)
        elif self._args.dumpdata:
            webapp.dumpdata(a=self._args.dumpdata)
        else:
            # Daemon run
            if not self._args.foreground:
                daemon.DaemonContext().open()

            # Incoming and builder queue
            incoming_queue = Queue.Queue(maxsize=0)
            build_queue = Queue.Queue(maxsize=0)

            # Start httpd and ftpd
            from mini_buildd import httpd, ftpd
            misc.start_thread(httpd.HttpD(self._args.httpd_bind, webapp))
            misc.start_thread(ftpd.FtpD(bind=self._args.ftpd_bind, queue=incoming_queue))

            # Start builder and dispatcher threads
            join_threads = []
            from mini_buildd.models import Dispatcher, Builder
            for d in Dispatcher.objects.all():
                join_threads.append(misc.start_thread(d, incoming_queue, build_queue))
            for b in Builder.objects.all():
                join_threads.append(misc.start_thread(b, build_queue))

            # Shutdown on SIGTERM or SIGINT
            self._run = True
            signal.signal(signal.SIGTERM, self.shutdown)
            signal.signal(signal.SIGINT, self.shutdown)
            while self._run:
                signal.pause()

            log.info("Signaling shutdown to dispatcher and builder...")
            incoming_queue.put("SHUTDOWN")
            build_queue.put("SHUTDOWN")

            for t in join_threads:
                log.info("Waiting for {i}".format(i=t))
                t.join()

            log.info("Shutdown complete. Bye...")

# Main processing; the only benefit of the master try/catch is
# that we can generate a error message to log on exception --
# most importantly, when we cannot start up
try:
    Main().run()
except:
    log.exception("mini-buildd run failed")
    sys.exit(1)
