#!/usr/bin/python

import string
import threading
import Queue
import signal
import os
import argparse
import sys
import time
import daemon
import logging
import logging.handlers

import mini_buildd

log = logging.getLogger("mini_buildd")

class Main():
    def parse_args(self):
        parser = argparse.ArgumentParser(prog="mini-buildd",
                                         description="mini build daemon.",
                                         formatter_class=argparse.ArgumentDefaultsHelpFormatter)

        parser.add_argument('--version', action='version', version=mini_buildd.__version__)

        parser.add_argument("-f", "--foreground", action='store_true',
                            help="Don't daemonize, log to console.")
        parser.add_argument("-W", "--httpd-bind", action='store', default="0.0.0.0:8066",
                            help="Web Server IP/Hostname and port to bind to.")
        parser.add_argument("-F", "--ftpd-bind", action='store', default="0.0.0.0:8067",
                            help="FTP Server IP/Hostname and port to bind to.")

        group_log = parser.add_argument_group("Logging")
        group_log.add_argument("-v", "--verbose", dest="verbosity", action='count', default=0,
                               help="Lower log level. Give twice for max logs.")
        group_log.add_argument("-q", "--quiet", dest="terseness", action='count', default=0,
                               help="Tighten log level. Give twice for min logs.")
        group_log.add_argument("-d", "--debug", action='store_true', default=False,
                               help="Enable 'debug mode'. This will set logging vebosity to max, and also \
tries to put external code into 'debug' mode as far as supported. Never use this for production.")
        group_log.add_argument("-l", "--loggers", action='store', default="syslog",
                               help="Comma-separated list of loggers (syslog, console, file) to use.")

        group_conf = parser.add_argument_group("Daemon configuration")
        group_conf.add_argument("-H", "--home", action='store', default=os.getenv('HOME'),
                                help="Run with this home dir. The only use case to change this for debugging, really.")
        group_conf.add_argument("-I", "--instdir", action='store', default="/usr/share/pyshared",
                                help="Run with this installation dir (where mini_buildd python module is located).")

        group_db = parser.add_argument_group("Database")
        group_db.add_argument("-P", "--set-admin-password", action='store', metavar="PASSWORD",
                              help="Update password for django superuser named 'admin'; user is created if non-existent yet.")
        group_db.add_argument("-C", "--create-default-config", action='store', metavar="MIRROR_URL",
                              help="Create an initial default config.")
        group_db.add_argument("-L", "--loaddata", action='store', metavar="FILE",
                              help="Import FILE to django database and exit. FILE is a absolute or relative (to 'INSTDIR/fixtures/') \
django fixture path (see 'django-admin dumpdata'), or an absolute path /PATH/*.conf for an old 0.8.x-style config.")
        group_db.add_argument("-D", "--dumpdata", action='store', metavar="APP[.MODEL]",
                              help="Dump app[.MODEL] from django database and exit (see 'django-admin loaddata').")

        return parser.parse_args()

    def configure_log(self):
        # Add predefinded handlers: console, syslog, file
        self._LOG_HANDLERS = {}
        self._LOG_HANDLERS["syslog"] = logging.handlers.SysLogHandler(address="/dev/log", facility=logging.handlers.SysLogHandler.LOG_USER)
        self._LOG_HANDLERS["console"] = logging.StreamHandler()
        self._LOG_HANDLERS["file"] = logging.FileHandler(self._args.home + "/.mini-buildd.log")

        # Global: Don't propagate exceptions that happen while logging
        logging.raiseExceptions = 0

        for h in string.split(self._args.loggers + (",console" if self._args.foreground else ""), ","):
            self._LOG_HANDLERS[h].setFormatter(logging.Formatter("%(name)-22s(%(lineno)03d): %(levelname)-8s: %(message)s"))
            log.addHandler(self._LOG_HANDLERS[h])

        # Finally, set log level
        loglevel = logging.DEBUG if self._args.debug else logging.WARNING-(10*(min(2, self._args.verbosity)-min(2, self._args.terseness)))
        log.setLevel(loglevel)

    def __init__(self):
        self._args = self.parse_args()
        self.configure_log()

        self._webapp = mini_buildd.WebApp(self._args.home, instdir=self._args.instdir, debug=self._args.debug)

        # Queue of all incoming files
        self._incoming_queue = Queue.Queue(maxsize=0)
        self._incoming_queue_regex = "^(.*\.changes|.*\.buildrequest|.*\.buildresult)$"

        self._httpd = mini_buildd.HttpD(self._args.httpd_bind, self._webapp)
        self._ftpd = mini_buildd.FtpD(bind=self._args.ftpd_bind, home=self._args.home,
                                      incoming="incoming", repositories="repositories",
                                      queue=self._incoming_queue, queue_regex=self._incoming_queue_regex)
        self._dispatcher = mini_buildd.Dispatcher(spool_dir=os.path.join(self._args.home, "spool"), queue=self._incoming_queue)
        self._run = True

    def prepare(self):
        from mini_buildd.models import Repository, Builder
        for r in Repository.objects.all():
            r.prepare()
        for b in Builder.objects.all():
            b.prepare()

    def shutdown(self, signum=-1, frame=-1):
        log.debug("Got signal: %s" % signum)
        self._run = False

    def run(self):
        # Extra options that exit without running Main() daemon
        if self._args.set_admin_password:
            self._webapp.set_admin_password(password=self._args.set_admin_password)
        elif self._args.create_default_config:
            self._webapp.create_default_config(mirror=self._args.create_default_config)
        elif self._args.loaddata:
            self._webapp.loaddata(f=self._args.loaddata)
        elif self._args.dumpdata:
            self._webapp.dumpdata(a=self._args.dumpdata)
        else:
            # Daemonize if configured
            if not self._args.foreground:
                daemon.DaemonContext().open()

            # Prepare home
            self.prepare()

            mini_buildd.misc.start_thread(self._httpd)
            mini_buildd.misc.start_thread(self._ftpd)
            mini_buildd.misc.start_thread(self._dispatcher)

            # Shutdown on SIGTERM or SIGINT
            signal.signal(signal.SIGTERM, self.shutdown)
            signal.signal(signal.SIGINT, self.shutdown)

            while self._run:
                signal.pause()

            log.info("Shutting down (%s active threads)" % threading.activeCount())
            log.info("Shutdown complete. Bye...")

# Main processing; the only benefit of the master try/catch is
# that we can generate a error message to log on exception --
# most importantly, when we cannot start up
try:
    Main().run()
except:
    log.exception("mini-buildd run failed")
    sys.exit(1)
