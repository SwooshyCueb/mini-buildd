#!/usr/bin/python

import threading
import Queue
import signal
import os
import sys
import time
import daemon

import mini_buildd

class Main():
    def __init__(self):
        self._webapp = mini_buildd.WebApp(mini_buildd.args.home, instdir=mini_buildd.args.instdir, debug=True)
        self._iQueue = Queue.Queue()
        from mini_buildd.models import Repository
        self._iWatchers = []
        for r in Repository.objects.all():
            self._iWatchers.append(mini_buildd.IWatcher(queue=self._iQueue, repository=r))

        #self._iWatcher  = mini_buildd.IWatcher (queue=self._iQueue, idir=mini_buildd.args.home + '/rep/incoming')
        self._installer = mini_buildd.Installer(queue=self._iQueue)
        self._ftpserver = mini_buildd.FtpServer(bind=mini_buildd.args.ftpserver_bind, path=os.path.join(mini_buildd.args.home, "incoming"), queue=self._iQueue)
        self._webserver = mini_buildd.WebServer(mini_buildd.args.webserver_bind, self._webapp)
        self._run = True

    def get_webapp(self):
        return self._webapp

    def prepare(self):
        from mini_buildd.models import Repository, Builder
        for r in Repository.objects.all():
            r.prepare()
        for b in Builder.objects.all():
            b.prepare()

    def shutdown(self, signum=-1, frame=-1):
        mini_buildd.log.debug("Got signal: %s" % signum)
        self._run = False

    def start_thread(self, obj):
        thread = threading.Thread(target=obj.run)
        thread.setDaemon(True)
        thread.start()

    def run(self):
        self.prepare()

        # Start watcher and installer
        for w in self._iWatchers:
            self.start_thread(w)
        self.start_thread(self._installer)
        self.start_thread(self._ftpserver)
        self.start_thread(self._webserver)

        # Shutdown on SIGTERM or SIGINT
        signal.signal(signal.SIGTERM, self.shutdown)
        signal.signal(signal.SIGINT, self.shutdown)

        while self._run:
            signal.pause()

        mini_buildd.log.info("Shutting down (%s active threads)" % threading.activeCount())
        mini_buildd.log.info("Shutdown complete. Bye...")

# Create main
main = Main()

# Execute extra options that exit without running Main() daemon
if mini_buildd.args.set_admin_password:
    main.get_webapp().set_admin_password(password=mini_buildd.args.set_admin_password)
    sys.exit(0)
elif mini_buildd.args.create_default_config:
    main.get_webapp().create_default_config(mirror=mini_buildd.args.create_default_config)
    sys.exit(0)
elif mini_buildd.args.loaddata:
    main.get_webapp().loaddata(f=mini_buildd.args.loaddata)
    sys.exit(0)
elif mini_buildd.args.dumpdata:
    main.get_webapp().dumpdata(a=mini_buildd.args.dumpdata)
    sys.exit(0)

# Daemonize if configured
if not mini_buildd.args.foreground:
    daemon.DaemonContext().open()

# Main processing; the only benefit of the master try/catch is
# that we can generate a error message to log on exception --
# most importantly, when we cannot start up
try:
    main.run()
except:
    mini_buildd.log.exception("mini-buildd run failed")
    sys.exit(1)
