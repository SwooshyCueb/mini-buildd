#!/usr/bin/python
# -*- coding: utf-8 -*-
from __future__ import unicode_literals
from __future__ import print_function

import sys
import os
import locale
import urllib
import urllib2
import argparse
import ConfigParser
import logging

import argcomplete

import mini_buildd.misc
import mini_buildd.setup
import mini_buildd.api

LOG = logging.getLogger("mini_buildd")
mini_buildd.misc.setup_console_logging(logging.DEBUG)

# pylint: disable=W0613
def host_completer(prefix, **kwargs):
    hosts = []
    dput_cf = ConfigParser.RawConfigParser()
    dput_cf.read(os.path.expanduser("~/.dput.cf"))
    for s in dput_cf.sections():
        try:
            host = dput_cf.get(s, "x_mini_buildd_host")
            hosts.append(host)
            tpl = "{u}@{h}"
            hosts.append(tpl.format(u="admin", h=host))
            try:
                users = dput_cf.get(s, "x_mini_buildd_users")
                if not users:
                    raise Exception()
            except:
                users = os.getenv("USER")
            for u in users.split(" "):
                hosts.append(tpl.format(u=u, h=host))
        except:
            pass
    return hosts
# pylint: enable=W0613

PARSER = argparse.ArgumentParser(prog="mini-buildd-tool",
                                 description="command line tool to run API calls.",
                                 formatter_class=argparse.ArgumentDefaultsHelpFormatter)

PARSER.add_argument("--version", action="version", version=mini_buildd.__version__)
PARSER.add_argument("-v", "--verbose", dest="verbosity", action="count", default=0,
                    help="lower log level. Give twice for max logs")
PARSER.add_argument("-q", "--quiet", dest="terseness", action="count", default=0,
                    help="tighten log level. Give twice for min logs")
PARSER.add_argument("-O", "--output", action="store",
                    default="plain", choices=["plain", "html", "python"],
                    help="output type")
PARSER.add_argument("host", action="store",
                    metavar="HOST",
                    help="target host").completer = host_completer

def print_daemon_messages(headers, host):
    "Output daemon messages to stderr"
    msgs_header = "x-mini-buildd-message"
    for msg in [v for k, v in headers.items() if msgs_header == k[:len(msgs_header)]]:
        print("[{h}] {m}".format(h=host, m=mini_buildd.misc.b642u(msg)), file=sys.stderr)
    print("", file=sys.stderr)

def cmd_call(args):
    user, dummy, host = args.host.rpartition("@")

    # Log in if user given explicitely, or required by the command
    if user or args.command_class.AUTH != mini_buildd.api.Command.NONE:
        mini_buildd.misc.web_login(host, user, CREDS_CACHE)

    # Compute api call parameters
    http_args = {}
    for k in [k for k in args.__dict__.keys() if k not in ["terseness", "verbosity", "host", "command_class", "func"]]:
        http_args[k] = args.__dict__[k]

    # Confirm if required by this call
    if args.command_class.CONFIRM:
        if not http_args["confirm"]:
            http_args["confirm"] = raw_input("Repeat command name to confirm: ")
        if not http_args["confirm"]:
            raise Exception("{c}: Not confirmed, skipped.".format(c=args.command))

    # Do the api call
    call_url = "http://{b}/mini_buildd/api?{a}".format(b=host, a=urllib.urlencode(http_args))
    LOG.info("API call URL: {u}".format(u=call_url))
    response = urllib2.urlopen(call_url)

    # Output daemon messages to stderr
    print_daemon_messages(response.headers, args.host)

    # Output result to stdout
    result = response.read()
    if sys.stdout.isatty() and http_args["output"] == "plain":
        # On plain output to a tty, try to encode to the preferred locale
        encoding = response.headers["content-type"].partition("charset=")[2]
        sys.stdout.write(unicode(result, encoding if encoding else "UTF-8").encode(locale.getpreferredencoding()))
    else:
        sys.stdout.write(result)


def extra_cmd_credentials(args):
    {"list": lambda: CREDS_CACHE.list(args.host),
     "clear": lambda: CREDS_CACHE.clear(args.host),
     "reset": CREDS_CACHE.reset}[args.command]()
    CREDS_CACHE.save()


# Unfortunaetely, we cannot group the commands (yet), see http://bugs.python.org/issue14037
SUBPARSERS = PARSER.add_subparsers(title="API commands")
for cmd, cmd_cls in mini_buildd.api.COMMANDS:
    if cmd != mini_buildd.api.COMMAND_GROUP:
        cmd_parser = SUBPARSERS.add_parser(cmd, help=cmd_cls.__doc__)
        for cmd_args, cmd_kvargs in cmd_cls.ARGUMENTS:
            cmd_parser.add_argument(*cmd_args, **cmd_kvargs)

        if cmd_cls.CONFIRM:
            cmd_parser.add_argument("--confirm", action="store", default="", metavar="COMMAND",
                                    help="this command needs user confirmation; this option allows to force-bypass that, by explicitly repeating the command")

        cmd_parser.set_defaults(func=cmd_call, command=cmd, command_class=cmd_cls)

# Add local "credentials" sub command
CREDS_PARSER = SUBPARSERS.add_parser("credentials", help="Manage local user credentials")
CREDS_PARSER.add_argument("command", action="store", metavar="COMMAND", default="list", choices=["list", "clear", "reset"], help="credentials command")
CREDS_PARSER.set_defaults(func=extra_cmd_credentials)


# Parse and run
argcomplete.autocomplete(PARSER)
ARGS = PARSER.parse_args()
LOG.setLevel(logging.WARNING - (10 * (min(2, ARGS.verbosity) - min(2, ARGS.terseness))))

if LOG.getEffectiveLevel() <= logging.DEBUG:
    mini_buildd.setup.DEBUG = ["exception"]

try:
    # Generate global credentials object
    CREDS_CACHE = mini_buildd.misc.CredsCache(os.path.join(os.getenv("HOME"), ".mini-buildd-tool.credentials"))

    # Run the command
    ARGS.func(ARGS)

except urllib2.HTTPError as e:
    print_daemon_messages(e.headers, ARGS.host)
    mini_buildd.setup.log_exception(LOG, ARGS.host, e)
    sys.exit(1)
except Exception as e:
    mini_buildd.setup.log_exception(LOG, "{u}".format(u=ARGS.host), e)
    sys.exit(2)
