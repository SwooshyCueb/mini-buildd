#!/usr/bin/python

import threading
import Queue
import signal
import os
import sys
import time
import daemon

import mini_buildd

class Main():
    def __init__(self):
        self._iQueue = Queue.Queue()
        self._iWatcher  = mini_buildd.IWatcher (queue=self._iQueue, idir=mini_buildd.opts.home + '/rep/incoming')
        self._installer = mini_buildd.Installer(queue=self._iQueue, no_act=mini_buildd.opts.no_act)
        self._django = mini_buildd.WebApp(debug=True)
        self._webserver = mini_buildd.WebServer(self._django._django)
        self._run = True

    def shutdown(self, signum=-1, frame=-1):
        mini_buildd.log.debug("Got signal: %s" % signum)
        self._run = False

    def start_thread(self, obj):
        thread = threading.Thread(target=obj.run)
        thread.setDaemon(True)
        thread.start()

    def run(self):
        # Start watcher and installer
        self.start_thread(self._iWatcher)
        self.start_thread(self._installer)
        self.start_thread(self._webserver)

        # Shutdown on SIGTERM or SIGINT
        signal.signal(signal.SIGTERM, self.shutdown)
        signal.signal(signal.SIGINT, self.shutdown)

        while self._run:
            signal.pause()

        mini_buildd.log.info("Shutting down (%s active threads)" % threading.activeCount())
        mini_buildd.log.info("Shutdown complete. Bye...")

# Execute extra options that exit without running Main() daemon
if mini_buildd.opts.loaddata:
    mini_buildd.WebApp().loaddata(f=mini_buildd.opts.loaddata)
    sys.exit(0)
elif mini_buildd.opts.dumpdata:
    mini_buildd.WebApp().dumpdata(a=mini_buildd.opts.dumpdata)
    sys.exit(0)

# Daemonize if configured
if not mini_buildd.opts.foreground:
    daemon.DaemonContext().open()

# Main processing; the only benefit of the master try/catch is
# that we can generate a error message to log on exception --
# most importantly, when we cannot start up
try:
    Main().run()
except:
    mini_buildd.log.exception("mini-buildd run failed")
    sys.exit(1)
