#!/usr/bin/python

import threading
import Queue
import signal
import os
import sys
import time
import datetime
import daemon

import mini_buildd

class Main():
    def __init__(self):
        self._iQueue = Queue.Queue()
        self._iWatcher  = mini_buildd.IWatcher (queue=self._iQueue, idir=mini_buildd.opts.home + '/rep/incoming')
        self._installer = mini_buildd.Installer(queue=self._iQueue, no_act=mini_buildd.opts.no_act)
        self._webapp = mini_buildd.WebApp(debug=True)
        self._webserver = mini_buildd.WebServer(self._webapp)
        self.prepHome()
        self._run = True

    def prepHome(self):
        mini_buildd.log.debug("Preparing home: {h}".format(h=mini_buildd.opts.home))
        for s in ["rep/conf", "rep/incoming", "log", ".mini-buildd/apt-secure.d", ".mini-buildd/debconf-preseed.d", ".mini-buildd/chroots-update.d"]:
            mini_buildd.misc.mkdirs(os.path.join(mini_buildd.opts.home, s))

        from mini_buildd.models import Repository
        for r in Repository.objects.all():
            p = os.path.join(mini_buildd.opts.home, "rep", r.id, "conf")
            mini_buildd.misc.mkdirs(p)
            mini_buildd.misc.mkdirs(os.path.join(p, "..", "incoming"))
            open(os.path.join(p, "distributions"), 'w').write(r.repreproConfig())

            open(os.path.join(p, "incoming"), 'w').write("""\
Name: INCOMING
TempDir: /tmp
IncomingDir: {i}
Allow: {allow}
""".format(i=os.path.join(p, "..", "incoming"), allow=" ".join(r.uploadable_dists)))

            open(os.path.join(p, "options"), 'w').write("""\
gnupghome {h}
""".format(h=os.path.join(p, "..", ".gnupg")))

            # Update all indices (or create on initial install) via reprepro
            mini_buildd.misc.run_cmd("reprepro --verbose --basedir='{d}' clearvanished".format(d=os.path.join(p, "..")), False)
            mini_buildd.misc.run_cmd("reprepro --verbose --basedir='{d}' export".format(d=os.path.join(p, "..")), False)

            mini_buildd.log.info("Prepared reprepro config: {d}".format(d=p))

        open(os.path.join(mini_buildd.opts.home, ".mini-buildd/README"), 'w').write("""
Automatically produced by mini-buildd on {date}.
Manual changes to this file are NOT preserved.

README for "~/.mini-buildd/": Place for local configuration

DO CHANGES ON THE REPOSITORY HOST ONLY. On builder-only hosts,
this directory is SYNCED from the repository host.

Preinstall hook
=====================================
Putting an executable file "preinstall" here will run this with
the full path to a "build" (i.e., all tests passed, to-be
installed) changes-file.

You may use this as temporary workaround to dput packages to
other repositories or to additionally use another package
manager like reprepro in parallel.

Base chroot maintenance customization
=====================================
Note that you only need any customization if you need to
apt-secure extra sources (for example bpo) or have other special
needs (like pre-seeding debconf variables).

 * "apt-secure.d/*.key":
   What   : Apt-secure custom keys for extra sources; keys are added to all base chroots.
   Used by: mbd-update-bld (/usr/share/mini-buildd/chroots-update.d/05_apt-secure).
   Note   : Don't touch auto-generated key 'auto-mini-buildd.key'.
 * "debconf-preseed.d/*.conf":
   What   : Pre-defined values for debconf (see debconf-set-selections).
   Used by: mbd-update-bld (/usr/share/mini-buildd/chroots-update.d/20_debconf-preseed).
   Note   : One noteable use case are licenses from non-free like in the sun-java packages.
 * "chroots-update.d/*.hook":
   What   : Custom hooks (shell snippets). Run in all base chroots as root (!).
   Used by: mbd-update-bld.
""".format(date=datetime.datetime.now()))

    def shutdown(self, signum=-1, frame=-1):
        mini_buildd.log.debug("Got signal: %s" % signum)
        self._run = False

    def start_thread(self, obj):
        thread = threading.Thread(target=obj.run)
        thread.setDaemon(True)
        thread.start()

    def run(self):
        # Start watcher and installer
        self.start_thread(self._iWatcher)
        self.start_thread(self._installer)
        self.start_thread(self._webserver)

        # Shutdown on SIGTERM or SIGINT
        signal.signal(signal.SIGTERM, self.shutdown)
        signal.signal(signal.SIGINT, self.shutdown)

        while self._run:
            signal.pause()

        mini_buildd.log.info("Shutting down (%s active threads)" % threading.activeCount())
        mini_buildd.log.info("Shutdown complete. Bye...")

# Execute extra options that exit without running Main() daemon
if mini_buildd.opts.loaddata:
    mini_buildd.WebApp().loaddata(f=mini_buildd.opts.loaddata)
    sys.exit(0)
elif mini_buildd.opts.dumpdata:
    mini_buildd.WebApp().dumpdata(a=mini_buildd.opts.dumpdata)
    sys.exit(0)

# Daemonize if configured
if not mini_buildd.opts.foreground:
    daemon.DaemonContext().open()

# Main processing; the only benefit of the master try/catch is
# that we can generate a error message to log on exception --
# most importantly, when we cannot start up
try:
    Main().run()
except:
    mini_buildd.log.exception("mini-buildd run failed")
    sys.exit(1)
