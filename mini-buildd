#!/usr/bin/python

import threading
import Queue
import signal
import os
import sys
import time
import daemon

from mini_buildd.options import opts
from mini_buildd.log import log
import mini_buildd.misc

from mini_buildd.iwatcher import IWatcher
from mini_buildd.installer import Installer
from mini_buildd.webserver import WebServer, Django

class Main():
    def __init__(self):
        self._iQueue = Queue.Queue()
        self._iWatcher  = IWatcher (queue=self._iQueue, idir=opts.home + '/rep/incoming')
        self._installer = Installer(queue=self._iQueue, no_act=opts.no_act)
        self._django = Django(debug=True)
        self._webserver = WebServer(self._django._django)
        self._run = True

    def shutdown(self, signum=-1, frame=-1):
        log.debug("Got signal: %s" % signum)
        self._run = False

    def start_thread(self, obj):
        thread = threading.Thread(target=obj.run)
        thread.setDaemon(True)
        thread.start()

    def run(self):
        # Start watcher and installer
        self.start_thread(self._iWatcher)
        self.start_thread(self._installer)
        self.start_thread(self._webserver)

        # Shutdown on SIGTERM or SIGINT
        signal.signal(signal.SIGTERM, self.shutdown)
        signal.signal(signal.SIGINT, self.shutdown)

        while self._run:
            signal.pause()

        log.info("Shutting down (%s active threads)" % threading.activeCount())
        log.info("Shutdown complete. Bye...")

# Execute extra options that exit without running Main() daemon
if opts.loaddata:
    Django().loaddata(f=opts.loaddata)
    sys.exit(0)
elif opts.dumpdata:
    Django().dumpdata(a=opts.dumpdata)
    sys.exit(0)

# Daemonize if configured
if not opts.foreground:
    daemon.DaemonContext().open()

# Main processing; the only benefit of the master try/catch is
# that we can generate a error message to log on exception --
# most importantly, when we cannot start up
try:
    Main().run()
except:
    log.exception("mini-buildd run failed")
    sys.exit(1)
