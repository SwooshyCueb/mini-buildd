#!/usr/bin/python
# -*- coding: utf-8 -*-

import signal
import os
import pwd
import argparse
import sys
import daemon
import logging
import logging.handlers

import mini_buildd
import mini_buildd.misc
import mini_buildd.setup
import mini_buildd.httpd

log = logging.getLogger("mini_buildd")
log.addHandler(logging.StreamHandler())

def parse_args():
    parser = argparse.ArgumentParser(prog="mini-buildd",
                                     description="mini build daemon.",
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('--version', action='version', version=mini_buildd.__version__)

    parser.add_argument("-f", "--foreground", action='store_true',
                        help="Don't daemonize, log to console.")
    parser.add_argument("-W", "--httpd-bind", action='store', default="0.0.0.0:8066",
                        help="Web Server IP/Hostname and port to bind to.")

    group_log = parser.add_argument_group("Logging")
    group_log.add_argument("-v", "--verbose", dest="verbosity", action='count', default=0,
                           help="Lower log level. Give twice for max logs.")
    group_log.add_argument("-q", "--quiet", dest="terseness", action='count', default=0,
                           help="Tighten log level. Give twice for min logs.")
    group_log.add_argument("-d", "--debug", action='store', default="", metavar="PART,..",
                           help="Comma-separated list of parts to put in 'debug mode'. Available parts: \
main,django,ftpd,build,sbuild")
    group_log.add_argument("-l", "--loggers", action='store', default="file,syslog",
                           help="Comma-separated list of loggers (file,syslog,console) to use.")

    group_conf = parser.add_argument_group("Daemon configuration")
    group_conf.add_argument("-H", "--home", action='store', default=os.getenv('HOME'),
                            help="Run with this home dir. The only use case to change this for debugging, really.")

    group_db = parser.add_argument_group("Database")
    group_db.add_argument("-P", "--set-admin-password", action='store', metavar="PASSWORD",
                          help="Update password for django superuser named 'admin'; user is created if non-existent yet.")
    group_db.add_argument("-L", "--loaddata", action='store', metavar="FILE",
                          help="Import FILE to django database and exit; must be an absolute path name.') \
django fixture path (see 'django-admin dumpdata'), or an absolute path /PATH/*.conf for an old 0.8.x-style config.")
    group_db.add_argument("-D", "--dumpdata", action='store', metavar="APP[.MODEL]",
                          help="Dump app[.MODEL] from django database and exit (see 'django-admin loaddata').")

    args = parser.parse_args()

    # Arguments that imply foreground mode
    if args.set_admin_password or args.loaddata or args.dumpdata:
        args.foreground = True

    return args

class Main():
    def _setup(self):
        # Set global variables that really make no sense to
        # propagate through
        mini_buildd.setup.DEBUG = self._args.debug.split(",")

        mini_buildd.setup.HOME_DIR = self._args.home

        mini_buildd.setup.INCOMING_DIR = os.path.join(self._args.home, "incoming")
        mini_buildd.setup.REPOSITORIES_DIR = os.path.join(self._args.home, "repositories")

        vardir = os.path.join(self._args.home, "var")
        mini_buildd.setup.LOG_DIR     = os.path.join(vardir, "log")
        mini_buildd.setup.CHROOTS_DIR = os.path.join(vardir, "chroots")
        mini_buildd.setup.CHROOT_LIBDIR = os.path.join("libdir")
        mini_buildd.setup.SPOOL_DIR   = os.path.join(vardir, "spool")

        if os.path.exists("./build/sphinx/html"):
            # A bit clumsy, but should work: Seems to be a development run
            mini_buildd.setup.MANUAL_DIR = os.path.realpath("./build/sphinx/html")
        else:
            mini_buildd.setup.MANUAL_DIR = os.path.realpath("/usr/share/doc/mini-buildd/html")

        # Create base directories
        mini_buildd.misc.mkdirs(mini_buildd.setup.INCOMING_DIR)
        mini_buildd.misc.mkdirs(mini_buildd.setup.REPOSITORIES_DIR)
        mini_buildd.misc.mkdirs(mini_buildd.setup.LOG_DIR)

    def _setup_logging(self):
        loggers = self._args.loggers.split(",")
        if self._args.foreground:
            loggers.append("console")

        log_format = "%(name)-22s(%(lineno)03d): %(levelname)-8s: %(message)s"

        # Clear all loggers now; this will remove the
        # preliminary console logger
        log.handlers = []

        if "file" in loggers:
            fh = logging.FileHandler(os.path.join(mini_buildd.setup.LOG_DIR, "daemon.log"))
            fh.setFormatter(logging.Formatter("%(asctime)s " + log_format))
            log.addHandler(fh)

        if "syslog" in loggers:
            sh = logging.handlers.SysLogHandler(address="/dev/log", facility=logging.handlers.SysLogHandler.LOG_USER)
            sh.setFormatter(logging.Formatter(log_format))
            log.addHandler(sh)

        if "console" in loggers:
            ch = logging.StreamHandler()
            ch.setFormatter(logging.Formatter("%(asctime)s " + log_format))
            log.addHandler(ch)

        # Finally, set log level
        loglevel = logging.WARNING-(10*(min(2, self._args.verbosity)-min(2, self._args.terseness)))
        log.setLevel(loglevel)

        # Global: Don't propagate exceptions that happen while logging
        logging.raiseExceptions = 0

    def _setup_environment(self):
        os.environ.clear()
        os.environ["HOME"] = self._args.home
        os.environ["PATH"] = "/usr/bin:/bin:/usr/sbin:/sbin"
        for k in ("USER", "LOGNAME"):
            os.environ[k] = pwd.getpwuid(os.getuid())[0]

    def __init__(self):
        self._args = parse_args()
        # Daemonize early
        if not self._args.foreground:
            daemon.DaemonContext(working_directory=self._args.home, umask=0022).open()
        self._setup()
        self._setup_logging()
        self._setup_environment()
        self._status = "RESTART"

    def on_signal(self, signum=-1, frame=-1):
        log.info("Got signal: {s} ({f})".format(s=signum, f=frame))
        if signum == signal.SIGTERM or signum == signal.SIGINT:
            self._status = "SHUTDOWN"
        elif signum == signal.SIGHUP:
            self._status = "RESTART"

    def run(self):
        from mini_buildd import webapp
        webapp = webapp.WebApp()

        # Extra options that exit without running as daemon
        if self._args.set_admin_password:
            webapp.set_admin_password(password=self._args.set_admin_password)
        elif self._args.loaddata:
            webapp.loaddata(f=self._args.loaddata)
        elif self._args.dumpdata:
            webapp.dumpdata(a=self._args.dumpdata)
        else:
            # Shutdown on SIGTERM or SIGINT
            signal.signal(signal.SIGTERM, self.on_signal)
            signal.signal(signal.SIGINT, self.on_signal)
            signal.signal(signal.SIGHUP, self.on_signal)

            import mini_buildd.daemon

            # Get one global daemon instance
            dm = mini_buildd.daemon.Manager()

            # Start httpd webapp
            mini_buildd.misc.run_as_thread(mini_buildd.httpd.run, daemon=False, bind=self._args.httpd_bind, wsgi_app=webapp)

            while True:
                signal.pause()
                if self._status == "RESTART":
                    dm.restart()
                else:
                    break

            dm.stop()
            mini_buildd.httpd.exit()

# Main
try:
    Main().run()
except Exception as e:
    S = "mini-buildd FAILED: {e}".format(e=str(e))
    if "main" in mini_buildd.setup.DEBUG:
        log.exception(S)
    else:
        sys.exit(S)
except SystemExit as e:
    sys.exit(e.code)
